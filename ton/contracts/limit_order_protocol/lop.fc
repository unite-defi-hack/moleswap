#include "../imports/stdlib.fc";
#include "../imports/utils.fc";
#include "../imports/op_codes.fc";
#include "../imports/errors.fc";
#include "../imports/message.fc";
#include "./getters.fc";
#include "./storage.fc";

#pragma version >=0.4.4;

const storage_fee = 5000000; ;; 0.005 TON
const exec_fee = 30000000;  ;; 0.03 TON
const reserve_fee = 1000000;  ;; 0.001 TON


() create_src_escrow(
    slice maker_address,
    slice maker_asset,
    int making_amount,
    int receiver_address,
    int taker_asset,
    int taking_amount,
    int order_hash,
    int hashlock,
    int creation_time,
    int expiration_time,
    int query_id
) impure inline {
    raw_reserve(reserve_fee, 4);

    cell data = begin_cell()
        .store_slice(my_address())
        .store_uint(order_hash, 256)
        .end_cell();
    cell state_init = calculate_state_init(data, storage::src_escrow_code);
    slice to_contract_address = calculate_contract_address(state_init);

    var msg_body = begin_cell()
        .store_op(op::create)
        .store_query_id(query_id)
        .store_uint(hashlock, 256)
        .store_uint(creation_time, 32)
        .store_uint(expiration_time, 32)
        .store_ref(
            begin_cell()
                .store_slice(maker_address)
                .store_slice(maker_asset)
                .store_coins(making_amount)
                .store_uint(receiver_address, 256)
                .end_cell()
        )
        .store_ref(
            begin_cell()
                .store_uint(taker_asset, 256)
                .store_uint(taking_amount, 128)
                .end_cell()
        )
        .end_cell();
    send_message_with_stateinit(to_contract_address, msg_body, state_init, 0, CARRY_REMAINING_BALANCE);
}

() create_dst_escrow(
    int maker_address,
    int maker_asset,
    int making_amount,
    slice receiver_address,
    slice taker_address,
    slice taker_asset,
    int taking_amount,
    int order_hash,
    int hashlock,
    int creation_time,
    int expiration_time,
    int query_id
) impure inline {
    raw_reserve(reserve_fee, 4);

    cell data = begin_cell()
        .store_slice(my_address())
        .store_uint(order_hash, 256)
        .end_cell();
    cell state_init = calculate_state_init(data, storage::dst_escrow_code);
    slice to_contract_address = calculate_contract_address(state_init);

    var msg_body = begin_cell()
        .store_op(op::create)
        .store_query_id(query_id)
        .store_uint(hashlock, 256)
        .store_uint(creation_time, 32)
        .store_uint(expiration_time, 32)
        .store_ref(
            begin_cell()
                .store_uint(maker_address, 256)
                .store_uint(maker_asset, 256)
                .store_uint(making_amount, 128)
                .store_slice(receiver_address)
                .end_cell()
        )
        .store_ref(
            begin_cell()
                .store_slice(taker_address)
                .store_slice(taker_asset)
                .store_coins(taking_amount)
                .end_cell()
        )
        .end_cell();
    send_message_with_stateinit(to_contract_address, msg_body, state_init, 0, CARRY_REMAINING_BALANCE);
}

(int) calculate_order_hash(
    slice maker_address,
    slice maker_asset,
    int making_amount,
    int receiver_address,
    int taker_asset,
    int taking_amount,
    int hashlock,
    int salt,
    int creation_time,
    int expiration_time
) inline {
    cell order_data = begin_cell()
        .store_slice(maker_address)
        .store_slice(maker_asset)
        .store_coins(making_amount)
        .store_uint(receiver_address, 256)
        .store_ref(
            begin_cell()
                .store_uint(taker_asset, 256)
                .store_uint(taking_amount, 128)
                .end_cell()
        )
        .store_ref(
            begin_cell()
                .store_uint(hashlock, 256)
                .store_uint(salt, 256)
                .store_uint(creation_time, 32)
                .store_uint(expiration_time, 32)
                .end_cell()
        )
        .end_cell();
    return cell_hash(order_data);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    if (op == op::create_order) {
        slice maker_address = in_msg_body~load_msg_addr();
        slice maker_asset = in_msg_body~load_msg_addr();
        int making_amount = in_msg_body~load_coins();
        int receiver_address = in_msg_body~load_uint(256);

        slice ds_to = (in_msg_body~load_ref()).begin_parse();
        int taker_asset = ds_to~load_uint(256);
        int taking_amount = ds_to~load_uint(128);

        int salt = ds_to~load_uint(256);
        int hashlock = ds_to~load_uint(256);
        int creation_time = ds_to~load_uint(32);
        int expiration_time = ds_to~load_uint(32);

        ;; not used for now
        ;; slice maker_traits = in_msg_body~load_ref();

        throw_unless(error::not_enough_ton, msg_value > making_amount + exec_fee);

        int order_hash = calculate_order_hash(
            maker_address,
            maker_asset,
            making_amount,
            receiver_address,
            taker_asset,
            taking_amount,
            hashlock,
            salt,
            creation_time,
            expiration_time
        );

        create_src_escrow(
            maker_address,
            maker_asset,
            making_amount,
            receiver_address,
            taker_asset,
            taking_amount,
            order_hash,
            hashlock,
            creation_time,
            expiration_time,
            query_id
        );

        return ();
    }

    if (op == op::claim_order) {
        int maker_address = in_msg_body~load_uint(256);
        int maker_asset = in_msg_body~load_uint(256);
        int making_amount = in_msg_body~load_uint(128);
        slice receiver_address = in_msg_body~load_msg_addr();

        slice ds_to = (in_msg_body~load_ref()).begin_parse();
        slice taker_address = ds_to~load_msg_addr();
        slice taker_asset = ds_to~load_msg_addr();
        int taking_amount = ds_to~load_coins();

        slice ds_auction = (in_msg_body~load_ref()).begin_parse();
        int order_hash = ds_auction~load_uint(256);
        int hashlock = ds_auction~load_uint(256);
        int creation_time = ds_auction~load_uint(32);
        int expiration_time = ds_auction~load_uint(32);

        create_dst_escrow(
            maker_address,
            maker_asset,
            making_amount,
            receiver_address,
            taker_address,
            taker_asset,
            taking_amount,
            order_hash,
            hashlock,
            creation_time,
            expiration_time,
            query_id
        );
        return ();
    }

    throw(0xffff);
}
