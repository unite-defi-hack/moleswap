#include "../imports/stdlib.fc";
#include "../imports/utils.fc";
#include "../imports/op_codes.fc";
#include "../imports/errors.fc";
#include "../imports/message.fc";
#include "./storage.fc";

#pragma version >=0.4.4;

const storage_fee = 5000000; ;; 0.005 TON
const exec_fee = 30000000;  ;; 0.03 TON
const reserve_fee = 1000000;  ;; 0.001 TON
global slice storage::admin_address;
global cell storage::escrow_code;

() load_data() inline {
    slice ds = get_data().begin_parse();
    storage::admin_address = ds~load_msg_addr();

}

cell calculate_state_init(cell data, cell code) inline {
    return begin_cell()
        .store_uint(0, 2)
        .store_dict(code)
        .store_dict(data)
        .store_uint(0, 1)
        .end_cell();
}

slice calculate_contract_address(cell state_init) inline {
    return begin_cell().store_uint(4, 3)
        .store_int(0, 8)
        .store_uint(cell_hash(state_init), 256)
        .end_cell()
        .begin_parse();
}

() create_src_escrow(
    slice maker_address,
    slice maker_asset,
    int making_amount,
) impure inline {
    raw_reserve(reserve_fee, 4);

    cell data = begin_cell()
        .store_slice(my_address())
        .end_cell();
    cell state_init = calculate_state_init(data, storage::escrow_code);
    slice to_contract_address = calculate_contract_address(state_init);

    var msg_body = begin_cell()
        .store_op(op::create)
        .store_ref(
            begin_cell()
                .store_slice(maker_address)
                .store_slice(maker_asset)
                .store_uint(making_amount, 128)
                .end_cell()
        )
        .end_cell();
    send_message_with_stateinit(to_contract_address, msg_body, state_init, 0, CARRY_REMAINING_BALANCE);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();

    if (op == op::create_ton_order) {
        slice maker_address = in_msg_body~load_msg_addr();
        slice maker_asset = in_msg_body~load_msg_addr();
        int making_amount = in_msg_body~load_coins();
        int receiver_address = in_msg_body~load_uint(256);

        throw_unless(error::not_enough_ton, msg_value > making_amount + exec_fee);

        create_src_escrow(
            maker_address,
            maker_asset,
            making_amount
        );

        return ();
    }

    throw(0xffff);
}
